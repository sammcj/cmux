"use node";
import { v } from "convex/values";
import { fetchInstallationAccessToken } from "../_shared/githubApp";
import { internal } from "./_generated/api";
import type { Doc } from "./_generated/dataModel";
import {
  internalAction,
  type ActionCtx,
} from "./_generated/server";
import { Octokit } from "octokit";
import {
  sanitizeDescription,
  sanitizeFileName,
  validateStorageUrl,
} from "@cmux/shared/screenshots/sanitize-markdown";

const CMUX_BASE_URL = "https://manaflow.com";
const UTM_PARAMS = "utm_source=github&utm_medium=pr_comment&utm_campaign=manaflow_bot";
const COMMENT_SIGNATURE = `_Generated by [manaflow](${CMUX_BASE_URL}?${UTM_PARAMS}&utm_content=signature)`;

/**
 * Resolves the Convex site URL for HTTP endpoints.
 * HTTP routes are served from .convex.site, not .convex.cloud
 */
const resolveConvexSiteUrl = (): string | null => {
  const explicitUrl = process.env.CONVEX_SITE_URL || process.env.CONVEX_URL || process.env.CONVEX_CLOUD_URL;
  if (explicitUrl) {
    return explicitUrl.replace(/\/$/, "").replace(".convex.cloud", ".convex.site");
  }
  const deployment = process.env.CONVEX_DEPLOYMENT;
  if (deployment) {
    return `https://${deployment}.convex.site`;
  }
  return null;
};


/**
 * Maps MIME types to file extensions for video files.
 */
const getVideoExtension = (mimeType: string): string => {
  const mimeToExt: Record<string, string> = {
    "video/mp4": "mp4",
    "video/webm": "webm",
    "video/quicktime": "mov",
    "video/x-msvideo": "avi",
    "image/apng": "apng",
  };
  return mimeToExt[mimeType.toLowerCase()] ?? "mp4";
};

/**
 * Check if a MIME type is for an animated image preview (GIF or APNG).
 * These render as animated images in GitHub comments.
 */
const isAnimatedPreviewMimeType = (mimeType: string): boolean => {
  const lower = mimeType.toLowerCase();
  return lower === "image/gif" || lower === "image/apng";
};

/**
 * Get the base name of a file (without extension).
 * e.g., "workflow.mp4" -> "workflow", "workflow.apng" -> "workflow"
 */
const getBaseName = (fileName: string): string => {
  const lastDot = fileName.lastIndexOf(".");
  return lastDot > 0 ? fileName.substring(0, lastDot) : fileName;
};

/**
 * Generates a media proxy URL for a Convex storage file.
 * This URL ends with a proper file extension (e.g., .mp4) which is required
 * for GitHub to recognize and potentially embed the video.
 */
const getMediaProxyUrl = (storageId: string, mimeType: string): string | null => {
  const siteUrl = resolveConvexSiteUrl();
  if (!siteUrl) {
    console.warn("[github_pr_comments] Could not resolve Convex site URL for media proxy");
    return null;
  }
  const extension = getVideoExtension(mimeType);
  return `${siteUrl}/api/media/${storageId}.${extension}`;
};

const ASSET_RELEASE_TAG = "manaflow-preview-assets";

/**
 * Upload a video file to GitHub using Release Assets API.
 * This is the official API that works with GitHub App installation tokens.
 *
 * Flow:
 * 1. Get or create a release tagged 'cmux-preview-assets'
 * 2. Upload the video as a release asset
 * 3. Return the asset download URL
 *
 * The URL can be embedded in comments using <video src="..." controls></video>
 */
async function uploadVideoToGitHub(options: {
  repoFullName: string;
  accessToken: string;
  videoData: ArrayBuffer;
  fileName: string;
  contentType: string;
}): Promise<{ ok: true; assetUrl: string } | { ok: false; error: string }> {
  const { repoFullName, accessToken, videoData, fileName, contentType } = options;
  const [owner, repo] = repoFullName.split("/");

  if (!owner || !repo) {
    return { ok: false, error: `Invalid repo name: ${repoFullName}` };
  }

  const headers = {
    "Authorization": `token ${accessToken}`,
    "Accept": "application/vnd.github+json",
    "X-GitHub-Api-Version": "2022-11-28",
  };

  try {
    // Step 1: Get or create the assets release
    console.log("[github_pr_comments] Getting or creating assets release...");

    let releaseId: number | null = null;

    // Try to get existing release
    const getReleaseResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/releases/tags/${ASSET_RELEASE_TAG}`,
      { headers }
    );

    if (getReleaseResponse.ok) {
      const releaseData = await getReleaseResponse.json() as { id: number };
      releaseId = releaseData.id;
      console.log("[github_pr_comments] Found existing release", { releaseId });
    } else if (getReleaseResponse.status === 404) {
      // Create new release
      console.log("[github_pr_comments] Creating new assets release...");

      // Get default branch
      const repoResponse = await fetch(
        `https://api.github.com/repos/${owner}/${repo}`,
        { headers }
      );

      if (!repoResponse.ok) {
        const error = await repoResponse.text();
        return { ok: false, error: `Failed to get repo info: ${error}` };
      }

      const repoData = await repoResponse.json() as { default_branch: string };
      const defaultBranch = repoData.default_branch;

      // Create the release
      const createReleaseResponse = await fetch(
        `https://api.github.com/repos/${owner}/${repo}/releases`,
        {
          method: "POST",
          headers: { ...headers, "Content-Type": "application/json" },
          body: JSON.stringify({
            tag_name: ASSET_RELEASE_TAG,
            target_commitish: defaultBranch,
            name: "Preview Assets (manaflow)",
            body: "Auto-generated release for storing preview screenshots and videos. Do not delete.",
            draft: false,
            prerelease: true,
          }),
        }
      );

      if (!createReleaseResponse.ok) {
        const error = await createReleaseResponse.text();
        return { ok: false, error: `Failed to create release: ${error}` };
      }

      const newRelease = await createReleaseResponse.json() as { id: number };
      releaseId = newRelease.id;
      console.log("[github_pr_comments] Created new release", { releaseId });
    } else {
      const error = await getReleaseResponse.text();
      return { ok: false, error: `Failed to get release: ${error}` };
    }

    // Step 2: Upload the video as a release asset
    console.log("[github_pr_comments] Uploading video as release asset...", {
      releaseId,
      fileName,
      size: videoData.byteLength,
    });

    // Generate unique filename with timestamp to avoid conflicts
    // Sanitize filename: remove spaces, parentheses, and other special chars that GitHub mangles
    // This ensures the final URL ends in .mp4 (not .1.mp4) so GitHub renders it as a video
    const timestamp = Date.now();
    const sanitizedFileName = fileName
      .replace(/\s+/g, "-")           // spaces to dashes
      .replace(/[()[\]{}]/g, "")      // remove brackets/parens
      .replace(/--+/g, "-")           // collapse multiple dashes
      .replace(/[^a-zA-Z0-9._-]/g, ""); // remove other special chars
    const uniqueFileName = `${timestamp}-${sanitizedFileName}`;

    const uploadUrl = `https://uploads.github.com/repos/${owner}/${repo}/releases/${releaseId}/assets?name=${encodeURIComponent(uniqueFileName)}`;

    const uploadResponse = await fetch(uploadUrl, {
      method: "POST",
      headers: {
        ...headers,
        "Content-Type": contentType,
        "Content-Length": String(videoData.byteLength),
      },
      body: videoData,
    });

    if (!uploadResponse.ok) {
      const error = await uploadResponse.text();
      console.error("[github_pr_comments] Failed to upload asset", {
        status: uploadResponse.status,
        error,
      });
      return { ok: false, error: `Failed to upload asset: ${uploadResponse.status} ${error}` };
    }

    const assetData = await uploadResponse.json() as {
      browser_download_url: string;
      id: number;
      name: string;
    };

    console.log("[github_pr_comments] Video uploaded successfully", {
      assetId: assetData.id,
      assetName: assetData.name,
      downloadUrl: assetData.browser_download_url,
    });

    return { ok: true, assetUrl: assetData.browser_download_url };
  } catch (error) {
    console.error("[github_pr_comments] Error uploading video to GitHub", { error });
    return {
      ok: false,
      error: error instanceof Error ? error.message : String(error)
    };
  }
}
const PREVIEW_SIGNATURE = `_Generated by [manaflow](${CMUX_BASE_URL}?${UTM_PARAMS}&utm_content=preview_signature) preview system_`;
const COMMENT_SIGNATURE_MATCHERS = [
  COMMENT_SIGNATURE,
  PREVIEW_SIGNATURE,
  // Legacy cmux.dev signatures for backwards compatibility
  "_Generated by [cmux](https://cmux.dev)",
  "_Generated by [cmux](https://cmux.dev) preview system_",
  `_Generated by [manaflow](${CMUX_BASE_URL})`, // New signature without UTM
  `_Generated by [manaflow](${CMUX_BASE_URL}) preview system_`, // New preview signature without UTM
];

type PreviewRunDoc = Doc<"previewRuns">;
type ScreenshotSetDoc = Doc<"taskRunScreenshotSets">;

const COLLAPSE_MARKER = "<!-- cmux-preview-collapsed -->";
const COLLAPSE_SUMMARY = "Older manaflow preview screenshots (latest comment is below)";
const MAX_COMMENTS_TO_COLLAPSE = 20;
const MAX_PREVIOUS_SCREENSHOT_SETS = 5;
const NON_UI_CHANGE_PATTERNS = [
  /no changes detected/i,
  /all changed files are binary/i,
];
const STATUS_SUMMARY_LABEL: Record<ScreenshotSetDoc["status"], string> = {
  completed: "‚úÖ Screenshots",
  failed: "‚ùå Failed",
  skipped: "‚ö†Ô∏è Skipped",
};

const formatTimestamp = (value?: number | null): string => {
  if (!value) {
    return "unknown time";
  }
  return new Date(value).toISOString().replace("T", " ").replace("Z", " UTC");
};

const formatCommitLabel = (set: ScreenshotSetDoc): string =>
  set.commitSha ? `\`${set.commitSha.slice(0, 7)}\`` : "latest commit";

const isNonUiChangeReason = (reason?: string | null): boolean => {
  if (!reason) {
    return false;
  }
  return NON_UI_CHANGE_PATTERNS.some((pattern) => pattern.test(reason));
};

const formatSkippedMessage = (reason?: string | null): string => {
  if (isNonUiChangeReason(reason)) {
    return [
      "No UI-impacting changes were detected, so screenshots were skipped.",
      reason ? `> ${reason}` : null,
    ]
      .filter(Boolean)
      .join("\n\n");
  }
  if (reason) {
    return `Screenshot capture was skipped.\n\n> ${reason}`;
  }
  return "Screenshot capture was skipped.";
};

const summarizeSet = (
  set: ScreenshotSetDoc,
  run?: PreviewRunDoc,
): string => {
  const prefix = STATUS_SUMMARY_LABEL[set.status] ?? "‚ÑπÔ∏è Preview";
  const commit = set.commitSha ? set.commitSha.slice(0, 7) : "unknown";
  const timestamp = formatTimestamp(set.capturedAt ?? run?.createdAt);
  return `${prefix} ‚Äì commit ${commit} (${timestamp})`;
};

/**
 * Formats a single screenshot image into markdown lines.
 * Shared helper to ensure consistent rendering across all codepaths.
 *
 * SECURITY: This function sanitizes user-controlled content (fileName, description)
 * to prevent markdown injection and data exfiltration attacks.
 * See: packages/shared/src/screenshots/sanitize-markdown.ts
 */
const formatScreenshotImageMarkdown = (
  storageUrl: string,
  fileName: string,
  description?: string,
  options?: { includeHeader?: boolean },
): string[] => {
  // Validate storage URL to prevent external URLs
  const validatedUrl = validateStorageUrl(storageUrl);
  if (!validatedUrl) {
    console.warn("[github_pr_comments] Skipping image with invalid storage URL", {
      storageUrl,
      fileName,
    });
    return [];
  }

  // Sanitize user-controlled content to prevent injection
  const safeFileName = sanitizeFileName(fileName);
  const safeDescription = sanitizeDescription(description);

  const lines: string[] = [];
  if (options?.includeHeader) {
    lines.push(`### ${safeFileName}`);
  }
  if (safeDescription) {
    lines.push(`**${safeDescription}**`, "");
  }
  lines.push(`![${safeFileName}](${validatedUrl})`, "");
  return lines;
};

/**
 * Formats a single video into markdown lines.
 * Uses a direct link to the video file since GitHub sanitizes HTML video tags.
 * The video URL should be a proxy URL ending in .mp4 for GitHub to recognize it.
 *
 * SECURITY: This function sanitizes user-controlled content (fileName, description)
 * to prevent markdown injection and data exfiltration attacks.
 */
const formatScreenshotVideoMarkdown = (
  videoUrl: string,
  fileName: string,
  description?: string,
  options?: { includeHeader?: boolean },
): string[] => {
  // Validate URL to prevent external URLs
  const validatedUrl = validateStorageUrl(videoUrl);
  if (!validatedUrl) {
    console.warn("[github_pr_comments] Skipping video with invalid URL", {
      videoUrl,
      fileName,
    });
    return [];
  }

  // Sanitize user-controlled content to prevent injection
  const safeFileName = sanitizeFileName(fileName);
  const safeDescription = sanitizeDescription(description);

  const lines: string[] = [];
  if (options?.includeHeader) {
    lines.push(`### üé¨ ${safeFileName}`);
  }
  if (safeDescription) {
    lines.push(`**${safeDescription}**`, "");
  }
  // GitHub will render a video URL on its own line as an embedded video player
  // if the URL ends with a recognized video extension (.mp4, .mov, .webm)
  // The proxy URL ends in .mp4 which GitHub should recognize
  lines.push(
    validatedUrl,
    "",
    `[Download video](${validatedUrl})`,
    "",
  );
  return lines;
};

/**
 * Options for rendering screenshot set markdown
 */
interface RenderScreenshotSetOptions {
  /** Map of storageId -> GitHub asset URL for videos already uploaded to GitHub */
  githubVideoUrls?: Map<string, string>;
  /** GitHub access token for uploading videos (if not pre-uploaded) */
  accessToken?: string;
  /** Repository full name for uploading videos */
  repoFullName?: string;
}

async function renderScreenshotSetMarkdown(
  ctx: ActionCtx,
  set: ScreenshotSetDoc,
  heading: string,
  options?: RenderScreenshotSetOptions,
): Promise<string> {
  const commitLabel = formatCommitLabel(set);
  const timestamp = formatTimestamp(set.capturedAt);
  const lines: string[] = [heading, ""];

  const imageCount = set.images.length;
  // Count unique video groups (GIF+MP4 pairs count as 1 video, not 2)
  const uniqueVideoBaseNames = new Set(
    (set.videos ?? []).map(v => getBaseName(v.fileName || "workflow.mp4"))
  );
  const videoCount = uniqueVideoBaseNames.size;
  const hasMedia = imageCount > 0 || videoCount > 0;

  if (set.status === "completed" && hasMedia) {
    // Check if the model explicitly detected no UI changes
    // hasUiChanges === false means model analyzed and found no UI changes - skip screenshots
    // hasUiChanges === undefined means not analyzed - show screenshots
    // hasUiChanges === true means model found UI changes - show screenshots
    if (set.hasUiChanges === false) {
      lines.push(
        `> **No UI changes detected** - The model analyzed this PR and determined there are no visual changes to the UI.`,
        "",
      );
      // Don't render screenshots/videos when model says no UI changes
    } else {
      // Build intro message with counts
      const parts: string[] = [];
      if (imageCount > 0) {
        parts.push(`${imageCount} screenshot${imageCount === 1 ? "" : "s"}`);
      }
      if (videoCount > 0) {
        parts.push(`${videoCount} video${videoCount === 1 ? "" : "s"}`);
      }
      const intro = `Captured ${parts.join(" and ")} for commit ${commitLabel} (${timestamp}).`;
      lines.push(intro, "");

      // Render videos FIRST - upload to GitHub Release Assets
      // Group videos by base name to pair animated preview (GIF/APNG) with MP4 (download)
      if (set.videos && set.videos.length > 0 && options?.accessToken && options?.repoFullName) {
        // Group videos by base name (e.g., "workflow.mp4" and "workflow.gif" share base "workflow")
        const videoGroups = new Map<string, {
          preview?: typeof set.videos[0];  // GIF or APNG for animated preview
          mp4?: typeof set.videos[0];
          other?: typeof set.videos[0];
        }>();

        for (const video of set.videos) {
          const fileName = video.fileName || "workflow.mp4";
          const baseName = getBaseName(fileName);
          const group = videoGroups.get(baseName) ?? {};

          if (isAnimatedPreviewMimeType(video.mimeType)) {
            group.preview = video;
          } else if (video.mimeType === "video/mp4") {
            group.mp4 = video;
          } else {
            group.other = video;
          }

          videoGroups.set(baseName, group);
        }

        // Process each video group
        for (const [baseName, group] of videoGroups) {
          try {
            let previewUrl: string | null = null;
            let mp4Url: string | null = null;
            const description = group.preview?.description || group.mp4?.description || group.other?.description;

            // Try to upload animated preview (GIF or APNG) if available
            if (group.preview) {
              const previewFile = group.preview;
              const ext = getVideoExtension(previewFile.mimeType);
              const previewFileName = previewFile.fileName || `${baseName}.${ext}`;

              const previewStorageUrl = await ctx.storage.getUrl(previewFile.storageId);
              if (previewStorageUrl) {
                const previewResponse = await fetch(previewStorageUrl);
                if (previewResponse.ok) {
                  const previewData = await previewResponse.arrayBuffer();
                  const previewUploadResult = await uploadVideoToGitHub({
                    repoFullName: options.repoFullName,
                    accessToken: options.accessToken,
                    videoData: previewData,
                    fileName: previewFileName,
                    contentType: previewFile.mimeType,
                  });
                  if (previewUploadResult.ok) {
                    previewUrl = previewUploadResult.assetUrl;
                    console.log("[github_pr_comments] Animated preview uploaded", {
                      storageId: previewFile.storageId,
                      mimeType: previewFile.mimeType,
                      assetUrl: previewUrl,
                    });
                  } else {
                    console.error("[github_pr_comments] Failed to upload preview to GitHub", {
                      storageId: previewFile.storageId,
                      error: previewUploadResult.error,
                    });
                  }
                } else {
                  console.error("[github_pr_comments] Failed to fetch preview from storage", {
                    storageId: previewFile.storageId,
                    status: previewResponse.status,
                  });
                }
              } else {
                console.warn("[github_pr_comments] Could not get storage URL for preview", {
                  storageId: previewFile.storageId,
                });
              }
            }

            // Try to upload MP4 if available
            if (group.mp4) {
              const mp4File = group.mp4;
              const mp4FileName = mp4File.fileName || `${baseName}.mp4`;

              const mp4StorageUrl = await ctx.storage.getUrl(mp4File.storageId);
              if (mp4StorageUrl) {
                const mp4Response = await fetch(mp4StorageUrl);
                if (mp4Response.ok) {
                  const mp4Data = await mp4Response.arrayBuffer();
                  const mp4UploadResult = await uploadVideoToGitHub({
                    repoFullName: options.repoFullName,
                    accessToken: options.accessToken,
                    videoData: mp4Data,
                    fileName: mp4FileName,
                    contentType: "video/mp4",
                  });
                  if (mp4UploadResult.ok) {
                    mp4Url = mp4UploadResult.assetUrl;
                    console.log("[github_pr_comments] MP4 uploaded", {
                      storageId: mp4File.storageId,
                      assetUrl: mp4Url,
                    });
                  } else {
                    console.error("[github_pr_comments] Failed to upload MP4 to GitHub", {
                      storageId: mp4File.storageId,
                      error: mp4UploadResult.error,
                    });
                  }
                }
              }
            }

            // Render based on what we have
            const safeDescription = sanitizeDescription(description);

            if (previewUrl) {
              // Have animated preview - show as animated image with optional MP4 download
              if (safeDescription) {
                // Caption with (video) link if MP4 is available
                if (mp4Url) {
                  lines.push(`**${safeDescription}** ([video](${mp4Url}))`, "");
                } else {
                  lines.push(`**${safeDescription}**`, "");
                }
              }
              const ext = group.preview ? getVideoExtension(group.preview.mimeType) : "gif";
              const safeFileName = sanitizeFileName(group.preview?.fileName || `${baseName}.${ext}`);
              lines.push(`![${safeFileName}](${previewUrl})`, "");
            } else if (mp4Url) {
              // No animated preview but have MP4 - show caption with video link
              if (safeDescription) {
                lines.push(`**${safeDescription}** ([video](${mp4Url}))`, "");
              } else {
                lines.push(`[video](${mp4Url})`, "");
              }
            } else if (group.other) {
              // Fall back to other video format
              const video = group.other;
              const fileName = video.fileName || `${baseName}.mp4`;

              const storageUrl = await ctx.storage.getUrl(video.storageId);
              if (storageUrl) {
                const videoResponse = await fetch(storageUrl);
                if (videoResponse.ok) {
                  const videoData = await videoResponse.arrayBuffer();
                  const uploadResult = await uploadVideoToGitHub({
                    repoFullName: options.repoFullName,
                    accessToken: options.accessToken,
                    videoData,
                    fileName,
                    contentType: video.mimeType,
                  });
                  if (uploadResult.ok) {
                    if (safeDescription) {
                      lines.push(`**${safeDescription}** ([video](${uploadResult.assetUrl}))`, "");
                    } else {
                      lines.push(`[video](${uploadResult.assetUrl})`, "");
                    }
                  }
                }
              }
            }
          } catch (error) {
            console.error("[github_pr_comments] Error processing video group", {
              baseName,
              error: error instanceof Error ? error.message : String(error),
            });
          }
        }
      } else if (set.videos && set.videos.length > 0) {
        console.warn("[github_pr_comments] Cannot upload videos - missing accessToken or repoFullName");
      }

      // Render images AFTER videos
      for (const image of set.images) {
        const storageUrl = await ctx.storage.getUrl(image.storageId);
        if (!storageUrl) continue;
        const fileName = image.fileName || "screenshot";
        lines.push(...formatScreenshotImageMarkdown(storageUrl, fileName, image.description));
      }
    }
  } else if (set.status === "failed") {
    lines.push(
      `Failed to capture screenshots for commit ${commitLabel}.`,
      "",
      set.error ? `> ${set.error}` : "> Unknown error",
      "",
    );
  } else if (set.status === "skipped") {
    lines.push(formatSkippedMessage(set.error), "");
  } else {
    lines.push("Screenshot status is unknown for this run.", "");
  }

  return lines.join("\n").replace(/\n{3,}/g, "\n\n").trimEnd();
}

const createOctokit = (token: string): Octokit => {
  return new Octokit({
    auth: token,
    userAgent: "cmux-github-bot",
    request: {
      timeout: 10_000,
    },
  });
};

const parseRepoFullName = (
  repoFullName: string,
): { owner: string; repo: string } | null => {
  const [owner, repo] = repoFullName.split("/");
  if (!owner || !repo) {
    return null;
  }
  return { owner, repo };
};

const collapseCommentBody = (body: string): string => {
  const trimmed = body.trim();
  if (trimmed.includes(COLLAPSE_MARKER)) {
    return trimmed;
  }
  return [
    COLLAPSE_MARKER,
    "<details>",
    `<summary>${COLLAPSE_SUMMARY}</summary>`,
    "",
    trimmed,
    "",
    "</details>",
  ]
    .join("\n")
    .replace(/\n{3,}/g, "\n\n")
    .trimEnd();
};

async function collapseOlderPreviewComments({
  octokit,
  owner,
  repo,
  prNumber,
  latestCommentId,
}: {
  octokit: Octokit;
  owner: string;
  repo: string;
  prNumber: number;
  latestCommentId: number;
}): Promise<void> {
  let collapsedCount = 0;
  const iterator = octokit.paginate.iterator(
    octokit.rest.issues.listComments,
    {
      owner,
      repo,
      issue_number: prNumber,
      per_page: 50,
    },
  );

  for await (const { data } of iterator) {
    for (const comment of data) {
      if (collapsedCount >= MAX_COMMENTS_TO_COLLAPSE) {
        return;
      }
      const { body } = comment;
      if (!body) continue;
      if (comment.id === latestCommentId) continue;
      const hasSignature = COMMENT_SIGNATURE_MATCHERS.some((signature) =>
        body.includes(signature),
      );
      if (!hasSignature) continue;

      const nextBody = collapseCommentBody(body);
      if (nextBody === body) continue;

      try {
        await octokit.rest.issues.updateComment({
          owner,
          repo,
          comment_id: comment.id,
          body: nextBody,
        });
        collapsedCount += 1;
        console.log("[github_pr_comments] Collapsed previous preview comment", {
          commentId: comment.id,
        });
      } catch (error) {
        console.error(
          "[github_pr_comments] Failed to collapse previous preview comment",
          {
            commentId: comment.id,
            error,
          },
        );
      }
    }
  }
}

/**
 * Finds an existing manaflow preview comment on a PR by checking for signature markers.
 * This is used as a fallback when githubCommentId is not stored on the preview run.
 * Returns the most recent non-collapsed comment if found.
 */
export const findExistingPreviewComment = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
  },
  handler: async (
    _ctx,
    { installationId, repoFullName, prNumber },
  ): Promise<{ ok: true; commentId: number | null } | { ok: false; error: string }> => {
    try {
      const accessToken = await fetchInstallationAccessToken(installationId);
      if (!accessToken) {
        console.error(
          "[github_pr_comments] Failed to get access token for finding preview comment",
          { installationId },
        );
        return { ok: false, error: "Failed to get access token" };
      }

      const repo = parseRepoFullName(repoFullName);
      if (!repo) {
        console.error("[github_pr_comments] Invalid repo full name", {
          repoFullName,
        });
        return { ok: false, error: "Invalid repository name" };
      }

      const octokit = createOctokit(accessToken);

      // Search through comments to find a manaflow preview comment that hasn't been collapsed
      // We want the most recent non-collapsed comment to update
      const iterator = octokit.paginate.iterator(
        octokit.rest.issues.listComments,
        {
          owner: repo.owner,
          repo: repo.repo,
          issue_number: prNumber,
          per_page: 50,
        },
      );

      let candidateComment: { id: number; createdAt: string } | null = null;

      for await (const { data } of iterator) {
        for (const comment of data) {
          const { body } = comment;
          if (!body) continue;

          // Check if this is a manaflow comment by signature
          const hasSignature = COMMENT_SIGNATURE_MATCHERS.some((signature) =>
            body.includes(signature),
          );
          if (!hasSignature) continue;

          // Skip comments that have been collapsed (they have the collapse marker)
          if (body.includes(COLLAPSE_MARKER)) continue;

          // Keep track of the most recent non-collapsed manaflow comment
          if (
            !candidateComment ||
            new Date(comment.created_at) > new Date(candidateComment.createdAt)
          ) {
            candidateComment = {
              id: comment.id,
              createdAt: comment.created_at,
            };
          }
        }
      }

      if (candidateComment) {
        console.log("[github_pr_comments] Found existing preview comment to update", {
          installationId,
          repoFullName,
          prNumber,
          commentId: candidateComment.id,
        });
        return { ok: true, commentId: candidateComment.id };
      }

      console.log("[github_pr_comments] No existing preview comment found", {
        installationId,
        repoFullName,
        prNumber,
      });
      return { ok: true, commentId: null };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error finding preview comment",
        {
          installationId,
          repoFullName,
          prNumber,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});

export const addPrReaction = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    content: v.literal("eyes"),
  },
  handler: async (
    _ctx,
    { installationId, repoFullName, prNumber, content },
  ) => {
    try {
      const accessToken = await fetchInstallationAccessToken(installationId);
      if (!accessToken) {
        console.error(
          "[github_pr_comments] Failed to get access token for installation",
          { installationId },
        );
        return { ok: false, error: "Failed to get access token" };
      }

      const repo = parseRepoFullName(repoFullName);
      if (!repo) {
        console.error("[github_pr_comments] Invalid repo full name", {
          repoFullName,
        });
        return {
          ok: false,
          error: "Invalid repository name",
        };
      }

      const octokit = createOctokit(accessToken);
      const { data } = await octokit.rest.reactions.createForIssue({
        owner: repo.owner,
        repo: repo.repo,
        issue_number: prNumber,
        content,
      });

      console.log("[github_pr_comments] Successfully added reaction", {
        installationId,
        repoFullName,
        prNumber,
        reactionId: data.id,
      });

      return { ok: true, reactionId: data.id };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error adding reaction",
        {
          installationId,
          repoFullName,
          prNumber,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});

/**
 * Posts an initial "in progress" preview comment to a GitHub PR.
 * This is called early in the preview process to give users immediate feedback
 * with the diff heatmap link while screenshots are still being captured.
 *
 * Returns the comment ID and URL which should be stored for later updates.
 *
 * NOTE: Superseded runs will still post their own comment but will NOT collapse
 * other comments. This prevents a superseded run from collapsing comments from
 * newer runs that superseded it.
 */
export const postInitialPreviewComment = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    previewRunId: v.id("previewRuns"),
  },
  handler: async (ctx, args): Promise<{ ok: true; commentId: number; commentUrl: string } | { ok: false; error: string }> => {
    const { installationId, repoFullName, prNumber, previewRunId } = args;

    try {
      const accessToken = await fetchInstallationAccessToken(installationId);
      if (!accessToken) {
        console.error(
          "[github_pr_comments] Failed to get access token for initial preview comment",
          { installationId },
        );
        return { ok: false, error: "Failed to get access token" };
      }

      const repo = parseRepoFullName(repoFullName);
      if (!repo) {
        console.error("[github_pr_comments] Invalid repo full name", {
          repoFullName,
        });
        return { ok: false, error: "Invalid repository name" };
      }

      const octokit = createOctokit(accessToken);

      // Build the initial comment with diff heatmap link and loading state
      const commentSections: string[] = ["## Preview Videos and Screenshots"];

      // Add diff heatmap link (available immediately)
      const heatmapUrl = `https://0github.com/${repoFullName}/pull/${prNumber}?${UTM_PARAMS}&utm_content=diff_heatmap`;
      commentSections.push(`<a href="${heatmapUrl}" target="_blank">Open Diff Heatmap</a>`);

      // Show loading state for screenshots
      commentSections.push(
        "‚è≥ **Preview screenshots are being captured...**",
        "",
        "_Workspace and dev browser links will appear here once the preview environment is ready._",
      );

      commentSections.push("---", PREVIEW_SIGNATURE);
      const commentBody = commentSections.join("\n\n");

      const { data } = await octokit.rest.issues.createComment({
        owner: repo.owner,
        repo: repo.repo,
        issue_number: prNumber,
        body: commentBody,
      });

      console.log("[github_pr_comments] Posted initial preview comment", {
        installationId,
        repoFullName,
        prNumber,
        commentId: data.id,
        commentUrl: data.html_url,
      });

      // Store the comment ID on the preview run for later updates
      // Note: We don't change status here to avoid overwriting a "superseded" status
      await ctx.runMutation(internal.previewRuns.updateStatus, {
        previewRunId,
        status: "running",
        githubCommentUrl: data.html_url,
        githubCommentId: data.id,
      });

      // Check if this run is superseded before collapsing other comments.
      // Superseded runs should NOT collapse other comments because there may be
      // newer runs whose comments we don't want to collapse.
      const supersessionCheck = await ctx.runQuery(
        internal.previewRuns.checkIfSuperseded,
        { previewRunId },
      );

      if (!supersessionCheck.superseded) {
        await collapseOlderPreviewComments({
          octokit,
          owner: repo.owner,
          repo: repo.repo,
          prNumber,
          latestCommentId: data.id,
        });
      } else {
        console.log("[github_pr_comments] Skipping collapse for superseded run", {
          previewRunId,
          prNumber,
          commentId: data.id,
          supersededBy: supersessionCheck.supersededBy,
        });
      }

      return { ok: true, commentId: data.id, commentUrl: data.html_url };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error posting initial preview comment",
        {
          installationId,
          repoFullName,
          prNumber,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});

/**
 * Updates an existing preview comment with screenshot results and workspace links.
 * This is called after screenshots are captured to update the initial "in progress" comment.
 */
export const updatePreviewComment = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    commentId: v.number(),
    screenshotSetId: v.id("taskRunScreenshotSets"),
    previewRunId: v.id("previewRuns"),
    // Optional links
    workspaceUrl: v.optional(v.string()),
    devServerUrl: v.optional(v.string()),
    // Previous runs for history
    includePreviousRuns: v.optional(v.boolean()),
    previewConfigId: v.optional(v.id("previewConfigs")),
  },
  handler: async (ctx, args): Promise<{ ok: true } | { ok: false; error: string }> => {
    const {
      installationId,
      repoFullName,
      prNumber,
      commentId,
      screenshotSetId,
      previewRunId,
      workspaceUrl,
      devServerUrl,
      includePreviousRuns = false,
      previewConfigId,
    } = args;

    try {
      const accessToken = await fetchInstallationAccessToken(installationId);
      if (!accessToken) {
        console.error(
          "[github_pr_comments] Failed to get access token for update preview comment",
          { installationId },
        );
        return { ok: false, error: "Failed to get access token" };
      }

      const repo = parseRepoFullName(repoFullName);
      if (!repo) {
        console.error("[github_pr_comments] Invalid repo full name", {
          repoFullName,
        });
        return { ok: false, error: "Invalid repository name" };
      }

      const octokit = createOctokit(accessToken);

      // First, fetch the existing comment to check if it's been collapsed
      let isCollapsed = false;
      try {
        const existingComment = await octokit.rest.issues.getComment({
          owner: repo.owner,
          repo: repo.repo,
          comment_id: commentId,
        });
        isCollapsed = existingComment.data.body?.includes(COLLAPSE_MARKER) ?? false;
        if (isCollapsed) {
          console.log("[github_pr_comments] Existing comment is collapsed, will preserve wrapper", {
            commentId,
          });
        }
      } catch (error) {
        console.warn("[github_pr_comments] Could not fetch existing comment to check collapse state", {
          commentId,
          error: error instanceof Error ? error.message : String(error),
        });
      }

      const screenshotSet = await ctx.runQuery(
        internal.previewScreenshots.getScreenshotSet,
        { screenshotSetId },
      );

      if (!screenshotSet) {
        console.error("[github_pr_comments] Screenshot set not found for update", {
          screenshotSetId,
        });
        return { ok: false, error: "Screenshot set not found" };
      }

      // Build comment sections
      const commentSections: string[] = ["## Preview Videos and Screenshots"];

      // Build links row (under the heading)
      const linkParts: string[] = [];
      if (workspaceUrl) {
        linkParts.push(`<a href="${workspaceUrl}?${UTM_PARAMS}&utm_content=workspace" target="_blank">Open Workspace (1 hr expiry)</a>`);
      }
      if (devServerUrl) {
        linkParts.push(`<a href="${devServerUrl}?${UTM_PARAMS}&utm_content=dev_browser" target="_blank">Open Dev Browser (1 hr expiry)</a>`);
      }
      linkParts.push(`<a href="https://0github.com/${repoFullName}/pull/${prNumber}?${UTM_PARAMS}&utm_content=diff_heatmap" target="_blank">Open Diff Heatmap</a>`);

      if (linkParts.length > 0) {
        commentSections.push(linkParts.join(" ¬∑ "));
      }

      // Options for rendering with GitHub video upload support
      const renderOptions: RenderScreenshotSetOptions = {
        accessToken,
        repoFullName,
      };

      // Render the main screenshot section
      const latestHeading = includePreviousRuns
        ? `### Latest commit ${formatCommitLabel(screenshotSet)}`
        : "";
      const latestSection = await renderScreenshotSetMarkdown(
        ctx,
        screenshotSet,
        latestHeading,
        renderOptions,
      );

      commentSections.push(latestSection);

      // Fetch and render previous runs if requested
      if (includePreviousRuns && previewConfigId) {
        const previousRuns =
          (await ctx.runQuery(internal.previewRuns.listByConfigAndPr, {
            previewConfigId,
            prNumber,
            limit: MAX_PREVIOUS_SCREENSHOT_SETS + 1,
          })) ?? [];

        const previousSetEntries: Array<{
          run: PreviewRunDoc;
          set: ScreenshotSetDoc;
        }> = [];
        for (const run of previousRuns) {
          if (run._id === previewRunId) continue;
          if (!run.screenshotSetId) continue;
          const priorSet = await ctx.runQuery(
            internal.previewScreenshots.getScreenshotSet,
            { screenshotSetId: run.screenshotSetId },
          );
          if (!priorSet) continue;
          previousSetEntries.push({ run, set: priorSet });
          if (previousSetEntries.length >= MAX_PREVIOUS_SCREENSHOT_SETS) {
            break;
          }
        }

        if (previousSetEntries.length > 0) {
          const collapsedSections: string[] = [];
          for (const entry of previousSetEntries) {
            const sectionHeading = `#### ${summarizeSet(entry.set, entry.run)}`;
            collapsedSections.push(
              await renderScreenshotSetMarkdown(ctx, entry.set, sectionHeading, renderOptions),
            );
          }

          const previousBlock = [
            "<details>",
            `<summary>Previous preview runs (${previousSetEntries.length})</summary>`,
            "",
            collapsedSections.join("\n\n---\n\n"),
            "",
            "</details>",
          ].join("\n");

          commentSections.push(previousBlock);
        }
      }

      commentSections.push("---", PREVIEW_SIGNATURE);
      let commentBody = commentSections.join("\n\n");

      // If the comment was previously collapsed by another agent, preserve the collapse wrapper
      if (isCollapsed) {
        commentBody = [
          COLLAPSE_MARKER,
          "<details>",
          `<summary>${COLLAPSE_SUMMARY}</summary>`,
          "",
          commentBody,
          "",
          "</details>",
        ]
          .join("\n")
          .replace(/\n{3,}/g, "\n\n")
          .trimEnd();
      }

      // Update the existing comment
      await octokit.rest.issues.updateComment({
        owner: repo.owner,
        repo: repo.repo,
        comment_id: commentId,
        body: commentBody,
      });

      console.log("[github_pr_comments] Updated preview comment with screenshots", {
        installationId,
        repoFullName,
        prNumber,
        commentId,
      });

      // Update the preview run status
      await ctx.runMutation(internal.previewRuns.updateStatus, {
        previewRunId,
        status: screenshotSet.status as "completed" | "failed" | "skipped",
        screenshotSetId,
      });


      return { ok: true };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error updating preview comment",
        {
          installationId,
          repoFullName,
          prNumber,
          commentId,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});

/**
 * Unified function to post preview comments to GitHub PRs.
 *
 * Options:
 * - includePreviousRuns: Include collapsible history of previous screenshot sets (default: false)
 * - workspaceUrl: Optional URL to include a "Open Workspace" link at the top
 * - devServerUrl: Optional URL for "Dev Server Preview" link
 * - previewConfigId: Required when includePreviousRuns is true, used to fetch history
 */
export const postPreviewComment = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    screenshotSetId: v.id("taskRunScreenshotSets"),
    previewRunId: v.id("previewRuns"),
    // Options for different behaviors
    includePreviousRuns: v.optional(v.boolean()),
    workspaceUrl: v.optional(v.string()),
    devServerUrl: v.optional(v.string()),
    previewConfigId: v.optional(v.id("previewConfigs")),
  },
  handler: async (ctx, args): Promise<{ ok: true; commentId?: number; commentUrl?: string } | { ok: false; error: string }> => {
    const {
      installationId,
      repoFullName,
      prNumber,
      screenshotSetId,
      previewRunId,
      includePreviousRuns = false,
      workspaceUrl,
      devServerUrl,
      previewConfigId,
    } = args;

    try {
      const accessToken = await fetchInstallationAccessToken(installationId);
      if (!accessToken) {
        console.error(
          "[github_pr_comments] Failed to get access token for preview comment",
          { installationId },
        );
        return { ok: false, error: "Failed to get access token" };
      }

      const repo = parseRepoFullName(repoFullName);
      if (!repo) {
        console.error("[github_pr_comments] Invalid repo full name", {
          repoFullName,
        });
        return { ok: false, error: "Invalid repository name" };
      }

      const octokit = createOctokit(accessToken);

      const screenshotSet = await ctx.runQuery(
        internal.previewScreenshots.getScreenshotSet,
        { screenshotSetId },
      );

      if (!screenshotSet) {
        console.error("[github_pr_comments] Screenshot set not found", {
          screenshotSetId,
        });
        return { ok: false, error: "Screenshot set not found" };
      }

      // Build comment sections
      const commentSections: string[] = ["## Preview Videos and Screenshots"];

      // Build links row (under the heading)
      // Using HTML anchor tags with target="_blank" to open links in new tabs
      const linkParts: string[] = [];
      if (workspaceUrl) {
        linkParts.push(`<a href="${workspaceUrl}?${UTM_PARAMS}&utm_content=workspace" target="_blank">Open Workspace (1 hr expiry)</a>`);
      }
      if (devServerUrl) {
        linkParts.push(`<a href="${devServerUrl}?${UTM_PARAMS}&utm_content=dev_browser" target="_blank">Open Dev Browser (1 hr expiry)</a>`);
      }
      linkParts.push(`<a href="https://0github.com/${repoFullName}/pull/${prNumber}?${UTM_PARAMS}&utm_content=diff_heatmap" target="_blank">Open Diff Heatmap</a>`);

      if (linkParts.length > 0) {
        commentSections.push(linkParts.join(" ¬∑ "));
      }

      // Options for rendering with GitHub video upload support
      const renderOptions: RenderScreenshotSetOptions = {
        accessToken,
        repoFullName,
      };

      // Render the main screenshot section
      const latestHeading = includePreviousRuns
        ? `### Latest commit ${formatCommitLabel(screenshotSet)}`
        : "";
      const latestSection = await renderScreenshotSetMarkdown(
        ctx,
        screenshotSet,
        latestHeading,
        renderOptions,
      );

      commentSections.push(latestSection);

      // Fetch and render previous runs if requested
      if (includePreviousRuns && previewConfigId) {
        const previousRuns =
          (await ctx.runQuery(internal.previewRuns.listByConfigAndPr, {
            previewConfigId,
            prNumber,
            limit: MAX_PREVIOUS_SCREENSHOT_SETS + 1,
          })) ?? [];

        const previousSetEntries: Array<{
          run: PreviewRunDoc;
          set: ScreenshotSetDoc;
        }> = [];
        for (const run of previousRuns) {
          if (run._id === previewRunId) continue;
          if (!run.screenshotSetId) continue;
          const priorSet = await ctx.runQuery(
            internal.previewScreenshots.getScreenshotSet,
            { screenshotSetId: run.screenshotSetId },
          );
          if (!priorSet) continue;
          previousSetEntries.push({ run, set: priorSet });
          if (previousSetEntries.length >= MAX_PREVIOUS_SCREENSHOT_SETS) {
            break;
          }
        }

        if (previousSetEntries.length > 0) {
          const collapsedSections: string[] = [];
          for (const entry of previousSetEntries) {
            const sectionHeading = `#### ${summarizeSet(entry.set, entry.run)}`;
            collapsedSections.push(
              await renderScreenshotSetMarkdown(ctx, entry.set, sectionHeading, renderOptions),
            );
          }

          const previousBlock = [
            "<details>",
            `<summary>Previous preview runs (${previousSetEntries.length})</summary>`,
            "",
            collapsedSections.join("\n\n---\n\n"),
            "",
            "</details>",
          ].join("\n");

          commentSections.push(previousBlock);
        }
      }

      commentSections.push("---", PREVIEW_SIGNATURE);
      const commentBody = commentSections.join("\n\n");

      const { data } = await octokit.rest.issues.createComment({
        owner: repo.owner,
        repo: repo.repo,
        issue_number: prNumber,
        body: commentBody,
      });

      console.log("[github_pr_comments] Successfully posted preview comment", {
        installationId,
        repoFullName,
        prNumber,
        commentId: data.id,
        commentUrl: data.html_url,
      });

      await ctx.runMutation(internal.previewRuns.updateStatus, {
        previewRunId,
        status: screenshotSet.status as "completed" | "failed" | "skipped",
        screenshotSetId,
        githubCommentUrl: data.html_url,
        githubCommentId: data.id,
      });

      // Check if this run is superseded before collapsing other comments.
      // Superseded runs should NOT collapse other comments because there may be
      // newer runs whose comments we don't want to collapse.
      const supersessionCheck = await ctx.runQuery(
        internal.previewRuns.checkIfSuperseded,
        { previewRunId },
      );

      if (!supersessionCheck.superseded) {
        await collapseOlderPreviewComments({
          octokit,
          owner: repo.owner,
          repo: repo.repo,
          prNumber,
          latestCommentId: data.id,
        });
      } else {
        console.log("[github_pr_comments] Skipping collapse for superseded run (postPreviewComment)", {
          previewRunId,
          prNumber,
          commentId: data.id,
          supersededBy: supersessionCheck.supersededBy,
        });
      }

      return { ok: true, commentId: data.id, commentUrl: data.html_url };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error posting preview comment",
        {
          installationId,
          repoFullName,
          prNumber,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});

export const addPrComment = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    body: v.string(),
  },
  handler: async (
    _ctx,
    { installationId, repoFullName, prNumber, body },
  ) => {
    try {
      const accessToken = await fetchInstallationAccessToken(installationId);
      if (!accessToken) {
        console.error(
          "[github_pr_comments] Failed to get access token for installation",
          { installationId },
        );
        return { ok: false, error: "Failed to get access token" };
      }

      const repo = parseRepoFullName(repoFullName);
      if (!repo) {
        console.error("[github_pr_comments] Invalid repo full name", {
          repoFullName,
        });
        return { ok: false, error: "Invalid repository name" };
      }

      const octokit = createOctokit(accessToken);
      const { data } = await octokit.rest.issues.createComment({
        owner: repo.owner,
        repo: repo.repo,
        issue_number: prNumber,
        body,
      });
      console.log("[github_pr_comments] Successfully added comment", {
        installationId,
        repoFullName,
        prNumber,
        commentId: data.id,
      });

      return { ok: true, commentId: data.id };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error adding comment",
        {
          installationId,
          repoFullName,
          prNumber,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});

type MediaItem = { url: string; fileName?: string; description?: string; type: "image" | "video" };

async function getMediaForPr(
  ctx: ActionCtx,
  {
    teamId,
    repoFullName,
    prNumber,
  }: {
    teamId: string;
    repoFullName: string;
    prNumber: number;
  },
): Promise<{ images: MediaItem[]; videos: MediaItem[] }> {
  try {
    const taskRuns = await ctx.runQuery(
      internal.github_pr_queries.findTaskRunsForPr,
      {
        teamId,
        repoFullName,
        prNumber,
      },
    );

    if (taskRuns.length === 0) {
      return { images: [], videos: [] };
    }

    const images: MediaItem[] = [];
    const videos: MediaItem[] = [];

    for (const run of taskRuns) {
      // TEMPORARY: Always process all runs - never skip based on existing screenshot set
      if (run.latestScreenshotSetId) {
        const screenshotSet = await ctx.runQuery(
          internal.github_pr_queries.getScreenshotSet,
          {
            screenshotSetId: run.latestScreenshotSetId,
          },
        );

        if (screenshotSet && screenshotSet.status === "completed") {
          for (const image of screenshotSet.images) {
            if (image.url) {
              images.push({
                url: image.url,
                fileName: image.fileName,
                description: image.description,
                type: "image",
              });
            }
          }
          // Also collect videos - use proxy URLs for GitHub compatibility
          if (screenshotSet.videos) {
            for (const video of screenshotSet.videos) {
              // Prefer proxy URL (ends in .mp4) for GitHub to recognize the video
              const proxyUrl = getMediaProxyUrl(video.storageId, video.mimeType);
              const videoUrl = proxyUrl ?? video.url;
              if (videoUrl) {
                videos.push({
                  url: videoUrl,
                  fileName: video.fileName,
                  description: video.description,
                  type: "video",
                });
              }
            }
          }
        }
      }
    }

    return { images, videos };
  } catch (error) {
    console.error(
      "[github_pr_comments] Error fetching media for PR",
      {
        teamId,
        repoFullName,
        prNumber,
        error,
      },
    );
    return { images: [], videos: [] };
  }
}

function formatMediaComment(
  media: { images: MediaItem[]; videos: MediaItem[] },
): string {
  const hasImages = media.images.length > 0;
  const hasVideos = media.videos.length > 0;

  if (!hasImages && !hasVideos) {
    return "";
  }

  let markdown = "## Screenshots\n\n";
  markdown += "Here are the screenshots from the latest run:\n\n";

  // Render images
  for (const image of media.images) {
    const title = image.fileName || "Screenshot";
    const lines = formatScreenshotImageMarkdown(image.url, title, image.description, { includeHeader: true });
    markdown += lines.join("\n") + "\n";
  }

  // Render videos
  for (const video of media.videos) {
    const title = video.fileName || "Video";
    const lines = formatScreenshotVideoMarkdown(video.url, title, video.description, { includeHeader: true });
    markdown += lines.join("\n") + "\n";
  }

  return markdown;
}

export const addScreenshotCommentToPr = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    teamId: v.string(),
  },
  handler: async (
    ctx,
    { installationId, repoFullName, prNumber, teamId },
  ): Promise<
    | { ok: true; commentId?: number; skipped?: boolean; reason?: string }
    | { ok: false; error: string }
  > => {
    try {
      const media = await getMediaForPr(ctx, {
        teamId,
        repoFullName,
        prNumber,
      });

      if (media.images.length === 0 && media.videos.length === 0) {
        console.log(
          "[github_pr_comments] No screenshots or videos found for PR",
          {
            installationId,
            repoFullName,
            prNumber,
          },
        );
        return { ok: true, skipped: true, reason: "No screenshots or videos found" };
      }

      const body = formatMediaComment(media);

      const result = await ctx.runAction(internal.github_pr_comments.addPrComment, {
        installationId,
        repoFullName,
        prNumber,
        body,
      });

      if (result.ok) {
        return { ok: true, commentId: result.commentId };
      }

      return { ok: false, error: result?.error ?? "Unknown error" };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error adding screenshot comment",
        {
          installationId,
          repoFullName,
          prNumber,
          teamId,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});
