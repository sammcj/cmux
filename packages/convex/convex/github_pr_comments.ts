"use node";
import { v } from "convex/values";
import { fetchInstallationAccessToken } from "../_shared/githubApp";
import { internal } from "./_generated/api";
import type { Doc } from "./_generated/dataModel";
import {
  internalAction,
  type ActionCtx,
} from "./_generated/server";
import { Octokit } from "octokit";

const CMUX_BASE_URL = "https://cmux.sh";
const UTM_PARAMS = "utm_source=github&utm_medium=pr_comment&utm_campaign=cmux_bot";
const COMMENT_SIGNATURE = `_Generated by [cmux](${CMUX_BASE_URL}?${UTM_PARAMS}&utm_content=signature)`;
const PREVIEW_SIGNATURE = `_Generated by [cmux](${CMUX_BASE_URL}?${UTM_PARAMS}&utm_content=preview_signature) preview system_`;
const COMMENT_SIGNATURE_MATCHERS = [
  COMMENT_SIGNATURE,
  PREVIEW_SIGNATURE,
  "_Generated by [cmux](https://cmux.dev)",
  `_Generated by [cmux](${CMUX_BASE_URL})`, // Legacy signature without UTM
  `_Generated by [cmux](${CMUX_BASE_URL}) preview system_`, // Legacy preview signature without UTM
];

type PreviewRunDoc = Doc<"previewRuns">;
type ScreenshotSetDoc = Doc<"taskRunScreenshotSets">;

const COLLAPSE_MARKER = "<!-- cmux-preview-collapsed -->";
const COLLAPSE_SUMMARY = "Older cmux preview screenshots (latest comment is above)";
const MAX_COMMENTS_TO_COLLAPSE = 20;
const MAX_PREVIOUS_SCREENSHOT_SETS = 5;
const NON_UI_CHANGE_PATTERNS = [
  /no changes detected/i,
  /all changed files are binary/i,
];
const STATUS_SUMMARY_LABEL: Record<ScreenshotSetDoc["status"], string> = {
  completed: "✅ Screenshots",
  failed: "❌ Failed",
  skipped: "⚠️ Skipped",
};

const formatTimestamp = (value?: number | null): string => {
  if (!value) {
    return "unknown time";
  }
  return new Date(value).toISOString().replace("T", " ").replace("Z", " UTC");
};

const formatCommitLabel = (set: ScreenshotSetDoc): string =>
  set.commitSha ? `\`${set.commitSha.slice(0, 7)}\`` : "latest commit";

const isNonUiChangeReason = (reason?: string | null): boolean => {
  if (!reason) {
    return false;
  }
  return NON_UI_CHANGE_PATTERNS.some((pattern) => pattern.test(reason));
};

const formatSkippedMessage = (reason?: string | null): string => {
  if (isNonUiChangeReason(reason)) {
    return [
      "No UI-impacting changes were detected, so screenshots were skipped.",
      reason ? `> ${reason}` : null,
    ]
      .filter(Boolean)
      .join("\n\n");
  }
  if (reason) {
    return `Screenshot capture was skipped.\n\n> ${reason}`;
  }
  return "Screenshot capture was skipped.";
};

const summarizeSet = (
  set: ScreenshotSetDoc,
  run?: PreviewRunDoc,
): string => {
  const prefix = STATUS_SUMMARY_LABEL[set.status] ?? "ℹ️ Preview";
  const commit = set.commitSha ? set.commitSha.slice(0, 7) : "unknown";
  const timestamp = formatTimestamp(set.capturedAt ?? run?.createdAt);
  return `${prefix} – commit ${commit} (${timestamp})`;
};

/**
 * Formats a single screenshot image into markdown lines.
 * Shared helper to ensure consistent rendering across all codepaths.
 */
const formatScreenshotImageMarkdown = (
  storageUrl: string,
  fileName: string,
  description?: string,
  options?: { includeHeader?: boolean },
): string[] => {
  const lines: string[] = [];
  if (options?.includeHeader) {
    lines.push(`### ${fileName}`);
  }
  if (description) {
    lines.push(`**${description}**`, "");
  }
  lines.push(`![${fileName}](${storageUrl})`, "");
  return lines;
};

async function renderScreenshotSetMarkdown(
  ctx: ActionCtx,
  set: ScreenshotSetDoc,
  heading: string,
): Promise<string> {
  const commitLabel = formatCommitLabel(set);
  const timestamp = formatTimestamp(set.capturedAt);
  const lines: string[] = [heading, ""];

  if (set.status === "completed" && set.images.length > 0) {
    // Check if the model explicitly detected no UI changes
    // hasUiChanges === false means model analyzed and found no UI changes - skip screenshots
    // hasUiChanges === undefined means not analyzed - show screenshots
    // hasUiChanges === true means model found UI changes - show screenshots
    if (set.hasUiChanges === false) {
      lines.push(
        `> **No UI changes detected** - The model analyzed this PR and determined there are no visual changes to the UI.`,
        "",
      );
      // Don't render screenshots when model says no UI changes
    } else {
      const count = set.images.length;
      const intro = `Captured ${count} screenshot${count === 1 ? "" : "s"} for commit ${commitLabel} (${timestamp}).`;
      lines.push(intro, "");
      for (const image of set.images) {
        const storageUrl = await ctx.storage.getUrl(image.storageId);
        if (!storageUrl) continue;
        const fileName = image.fileName || "screenshot";
        lines.push(...formatScreenshotImageMarkdown(storageUrl, fileName, image.description));
      }
    }
  } else if (set.status === "failed") {
    lines.push(
      `Failed to capture screenshots for commit ${commitLabel}.`,
      "",
      set.error ? `> ${set.error}` : "> Unknown error",
      "",
    );
  } else if (set.status === "skipped") {
    lines.push(formatSkippedMessage(set.error), "");
  } else {
    lines.push("Screenshot status is unknown for this run.", "");
  }

  return lines.join("\n").replace(/\n{3,}/g, "\n\n").trimEnd();
}

const createOctokit = (token: string): Octokit => {
  return new Octokit({
    auth: token,
    userAgent: "cmux-github-bot",
    request: {
      timeout: 10_000,
    },
  });
};

const parseRepoFullName = (
  repoFullName: string,
): { owner: string; repo: string } | null => {
  const [owner, repo] = repoFullName.split("/");
  if (!owner || !repo) {
    return null;
  }
  return { owner, repo };
};

const collapseCommentBody = (body: string): string => {
  const trimmed = body.trim();
  if (trimmed.includes(COLLAPSE_MARKER)) {
    return trimmed;
  }
  return [
    COLLAPSE_MARKER,
    "<details>",
    `<summary>${COLLAPSE_SUMMARY}</summary>`,
    "",
    trimmed,
    "",
    "</details>",
  ]
    .join("\n")
    .replace(/\n{3,}/g, "\n\n")
    .trimEnd();
};

async function collapseOlderPreviewComments({
  octokit,
  owner,
  repo,
  prNumber,
  latestCommentId,
}: {
  octokit: Octokit;
  owner: string;
  repo: string;
  prNumber: number;
  latestCommentId: number;
}): Promise<void> {
  let collapsedCount = 0;
  const iterator = octokit.paginate.iterator(
    octokit.rest.issues.listComments,
    {
      owner,
      repo,
      issue_number: prNumber,
      per_page: 50,
    },
  );

  for await (const { data } of iterator) {
    for (const comment of data) {
      if (collapsedCount >= MAX_COMMENTS_TO_COLLAPSE) {
        return;
      }
      const { body } = comment;
      if (!body) continue;
      if (comment.id === latestCommentId) continue;
      const hasSignature = COMMENT_SIGNATURE_MATCHERS.some((signature) =>
        body.includes(signature),
      );
      if (!hasSignature) continue;

      const nextBody = collapseCommentBody(body);
      if (nextBody === body) continue;

      try {
        await octokit.rest.issues.updateComment({
          owner,
          repo,
          comment_id: comment.id,
          body: nextBody,
        });
        collapsedCount += 1;
        console.log("[github_pr_comments] Collapsed previous preview comment", {
          commentId: comment.id,
        });
      } catch (error) {
        console.error(
          "[github_pr_comments] Failed to collapse previous preview comment",
          {
            commentId: comment.id,
            error,
          },
        );
      }
    }
  }
}

export const addPrReaction = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    content: v.literal("eyes"),
  },
  handler: async (
    _ctx,
    { installationId, repoFullName, prNumber, content },
  ) => {
    try {
      const accessToken = await fetchInstallationAccessToken(installationId);
      if (!accessToken) {
        console.error(
          "[github_pr_comments] Failed to get access token for installation",
          { installationId },
        );
        return { ok: false, error: "Failed to get access token" };
      }

      const repo = parseRepoFullName(repoFullName);
      if (!repo) {
        console.error("[github_pr_comments] Invalid repo full name", {
          repoFullName,
        });
        return {
          ok: false,
          error: "Invalid repository name",
        };
      }

      const octokit = createOctokit(accessToken);
      const { data } = await octokit.rest.reactions.createForIssue({
        owner: repo.owner,
        repo: repo.repo,
        issue_number: prNumber,
        content,
      });

      console.log("[github_pr_comments] Successfully added reaction", {
        installationId,
        repoFullName,
        prNumber,
        reactionId: data.id,
      });

      return { ok: true, reactionId: data.id };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error adding reaction",
        {
          installationId,
          repoFullName,
          prNumber,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});

/**
 * Unified function to post preview comments to GitHub PRs.
 *
 * Options:
 * - includePreviousRuns: Include collapsible history of previous screenshot sets (default: false)
 * - workspaceUrl: Optional URL to include a "Open Workspace" link at the top
 * - devServerUrl: Optional URL for "Dev Server Preview" link
 * - previewConfigId: Required when includePreviousRuns is true, used to fetch history
 */
export const postPreviewComment = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    screenshotSetId: v.id("taskRunScreenshotSets"),
    previewRunId: v.id("previewRuns"),
    // Options for different behaviors
    includePreviousRuns: v.optional(v.boolean()),
    workspaceUrl: v.optional(v.string()),
    devServerUrl: v.optional(v.string()),
    previewConfigId: v.optional(v.id("previewConfigs")),
  },
  handler: async (ctx, args): Promise<{ ok: true; commentId?: number; commentUrl?: string } | { ok: false; error: string }> => {
    const {
      installationId,
      repoFullName,
      prNumber,
      screenshotSetId,
      previewRunId,
      includePreviousRuns = false,
      workspaceUrl,
      devServerUrl,
      previewConfigId,
    } = args;

    try {
      const accessToken = await fetchInstallationAccessToken(installationId);
      if (!accessToken) {
        console.error(
          "[github_pr_comments] Failed to get access token for preview comment",
          { installationId },
        );
        return { ok: false, error: "Failed to get access token" };
      }

      const repo = parseRepoFullName(repoFullName);
      if (!repo) {
        console.error("[github_pr_comments] Invalid repo full name", {
          repoFullName,
        });
        return { ok: false, error: "Invalid repository name" };
      }

      const octokit = createOctokit(accessToken);

      const screenshotSet = await ctx.runQuery(
        internal.previewScreenshots.getScreenshotSet,
        { screenshotSetId },
      );

      if (!screenshotSet) {
        console.error("[github_pr_comments] Screenshot set not found", {
          screenshotSetId,
        });
        return { ok: false, error: "Screenshot set not found" };
      }

      // Build comment sections
      const commentSections: string[] = ["## Preview Screenshots"];

      // Build links row (under the heading)
      const linkParts: string[] = [];
      if (workspaceUrl) {
        linkParts.push(`[Open Workspace (1 hr expiry)](${workspaceUrl}?${UTM_PARAMS}&utm_content=workspace)`);
      }
      if (devServerUrl) {
        linkParts.push(`[Open Dev Browser (1 hr expiry)](${devServerUrl}?${UTM_PARAMS}&utm_content=dev_browser)`);
      }
      linkParts.push(`[Open Diff Heatmap](https://0github.com/${repoFullName}/pull/${prNumber}?${UTM_PARAMS}&utm_content=diff_heatmap)`);

      if (linkParts.length > 0) {
        commentSections.push(linkParts.join(" · "));
      }

      // Render the main screenshot section
      const latestHeading = includePreviousRuns
        ? `### Latest commit ${formatCommitLabel(screenshotSet)}`
        : "";
      const latestSection = await renderScreenshotSetMarkdown(
        ctx,
        screenshotSet,
        latestHeading,
      );

      commentSections.push(latestSection);

      // Fetch and render previous runs if requested
      if (includePreviousRuns && previewConfigId) {
        const previousRuns =
          (await ctx.runQuery(internal.previewRuns.listByConfigAndPr, {
            previewConfigId,
            prNumber,
            limit: MAX_PREVIOUS_SCREENSHOT_SETS + 1,
          })) ?? [];

        const previousSetEntries: Array<{
          run: PreviewRunDoc;
          set: ScreenshotSetDoc;
        }> = [];
        for (const run of previousRuns) {
          if (run._id === previewRunId) continue;
          if (!run.screenshotSetId) continue;
          const priorSet = await ctx.runQuery(
            internal.previewScreenshots.getScreenshotSet,
            { screenshotSetId: run.screenshotSetId },
          );
          if (!priorSet) continue;
          previousSetEntries.push({ run, set: priorSet });
          if (previousSetEntries.length >= MAX_PREVIOUS_SCREENSHOT_SETS) {
            break;
          }
        }

        if (previousSetEntries.length > 0) {
          const collapsedSections: string[] = [];
          for (const entry of previousSetEntries) {
            const sectionHeading = `#### ${summarizeSet(entry.set, entry.run)}`;
            collapsedSections.push(
              await renderScreenshotSetMarkdown(ctx, entry.set, sectionHeading),
            );
          }

          const previousBlock = [
            "<details>",
            `<summary>Previous preview runs (${previousSetEntries.length})</summary>`,
            "",
            collapsedSections.join("\n\n---\n\n"),
            "",
            "</details>",
          ].join("\n");

          commentSections.push(previousBlock);
        }
      }

      commentSections.push("---", PREVIEW_SIGNATURE);
      const commentBody = commentSections.join("\n\n");

      const { data } = await octokit.rest.issues.createComment({
        owner: repo.owner,
        repo: repo.repo,
        issue_number: prNumber,
        body: commentBody,
      });

      console.log("[github_pr_comments] Successfully posted preview comment", {
        installationId,
        repoFullName,
        prNumber,
        commentId: data.id,
        commentUrl: data.html_url,
      });

      await ctx.runMutation(internal.previewRuns.updateStatus, {
        previewRunId,
        status: screenshotSet.status as "completed" | "failed" | "skipped",
        screenshotSetId,
        githubCommentUrl: data.html_url,
        githubCommentId: data.id,
      });

      await collapseOlderPreviewComments({
        octokit,
        owner: repo.owner,
        repo: repo.repo,
        prNumber,
        latestCommentId: data.id,
      });

      return { ok: true, commentId: data.id, commentUrl: data.html_url };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error posting preview comment",
        {
          installationId,
          repoFullName,
          prNumber,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});

export const addPrComment = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    body: v.string(),
  },
  handler: async (
    _ctx,
    { installationId, repoFullName, prNumber, body },
  ) => {
    try {
      const accessToken = await fetchInstallationAccessToken(installationId);
      if (!accessToken) {
        console.error(
          "[github_pr_comments] Failed to get access token for installation",
          { installationId },
        );
        return { ok: false, error: "Failed to get access token" };
      }

      const repo = parseRepoFullName(repoFullName);
      if (!repo) {
        console.error("[github_pr_comments] Invalid repo full name", {
          repoFullName,
        });
        return { ok: false, error: "Invalid repository name" };
      }

      const octokit = createOctokit(accessToken);
      const { data } = await octokit.rest.issues.createComment({
        owner: repo.owner,
        repo: repo.repo,
        issue_number: prNumber,
        body,
      });
      console.log("[github_pr_comments] Successfully added comment", {
        installationId,
        repoFullName,
        prNumber,
        commentId: data.id,
      });

      return { ok: true, commentId: data.id };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error adding comment",
        {
          installationId,
          repoFullName,
          prNumber,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});

async function getScreenshotsForPr(
  ctx: ActionCtx,
  {
    teamId,
    repoFullName,
    prNumber,
  }: {
    teamId: string;
    repoFullName: string;
    prNumber: number;
  },
): Promise<Array<{ url: string; fileName?: string; description?: string }>> {
  try {
    const taskRuns = await ctx.runQuery(
      internal.github_pr_queries.findTaskRunsForPr,
      {
        teamId,
        repoFullName,
        prNumber,
      },
    );

    if (taskRuns.length === 0) {
      return [];
    }

    const screenshots: Array<{ url: string; fileName?: string; description?: string }> = [];

    for (const run of taskRuns) {
      if (run.latestScreenshotSetId) {
        const screenshotSet = await ctx.runQuery(
          internal.github_pr_queries.getScreenshotSet,
          {
            screenshotSetId: run.latestScreenshotSetId,
          },
        );

        if (screenshotSet && screenshotSet.status === "completed") {
          for (const image of screenshotSet.images) {
            if (image.url) {
              screenshots.push({
                url: image.url,
                fileName: image.fileName,
                description: image.description,
              });
            }
          }
        }
      }
    }

    return screenshots;
  } catch (error) {
    console.error(
      "[github_pr_comments] Error fetching screenshots for PR",
      {
        teamId,
        repoFullName,
        prNumber,
        error,
      },
    );
    return [];
  }
}

function formatScreenshotComment(
  screenshots: Array<{ url: string; fileName?: string; description?: string }>,
): string {
  if (screenshots.length === 0) {
    return "";
  }

  let markdown = "## Screenshots\n\n";
  markdown +=
    "Here are the screenshots from the latest run:\n\n";

  for (const screenshot of screenshots) {
    const title = screenshot.fileName || "Screenshot";
    const lines = formatScreenshotImageMarkdown(screenshot.url, title, screenshot.description, { includeHeader: true });
    markdown += lines.join("\n") + "\n";
  }

  return markdown;
}

export const addScreenshotCommentToPr = internalAction({
  args: {
    installationId: v.number(),
    repoFullName: v.string(),
    prNumber: v.number(),
    teamId: v.string(),
  },
  handler: async (
    ctx,
    { installationId, repoFullName, prNumber, teamId },
  ): Promise<
    | { ok: true; commentId?: number; skipped?: boolean; reason?: string }
    | { ok: false; error: string }
  > => {
    try {
      const screenshots = await getScreenshotsForPr(ctx, {
        teamId,
        repoFullName,
        prNumber,
      });

      if (screenshots.length === 0) {
        console.log(
          "[github_pr_comments] No screenshots found for PR",
          {
            installationId,
            repoFullName,
            prNumber,
          },
        );
        return { ok: true, skipped: true, reason: "No screenshots found" };
      }

      const body = formatScreenshotComment(screenshots);

      const result = await ctx.runAction(internal.github_pr_comments.addPrComment, {
        installationId,
        repoFullName,
        prNumber,
        body,
      });

      if (result.ok) {
        return { ok: true, commentId: result.commentId };
      }

      return { ok: false, error: result?.error ?? "Unknown error" };
    } catch (error) {
      console.error(
        "[github_pr_comments] Unexpected error adding screenshot comment",
        {
          installationId,
          repoFullName,
          prNumber,
          teamId,
          error,
        },
      );
      return {
        ok: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  },
});
